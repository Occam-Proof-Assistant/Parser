'use strict';

var grammar = '\n\n  term                  ::=   forall binders , term term\'\n  \n                          |   fun binders => term term\'\n  \n                          |   fix fix_bodies term\'\n  \n                          |   cofix cofix_bodies term\'\n  \n                          |   let let\' term\'\n  \n                          |   if term dep_ret_type? then term else term term\'\n  \n                          |   @ qualid terms? term\'\n  \n                          |   match match_items return_type? with orEquations? end term\'\n\n                          |   qualid term\'\n\n                          |   sort term\'\n\n                          |   num term\'\n\n                          |   _ term\'\n\n                          |   ( term ) term\'\n                          \n                          \n                          \n  term\'                 ::=   : term term\'\n  \n                          |   <: term term\'\n  \n                          |   :> term\'\n  \n                          |   -> term term\'\n  \n                          |   arg+ term\'\n  \n                          |   % ident term\'\n  \n                          |   \u03B5\n                          \n                          \n                          \n  let\'                  ::=   ident binders? colonThenTerm? := term in term\n  \n                          |   fix fix_body in term\n  \n                          |   cofix cofix_body in term\n  \n                          |   ( names ) dep_ret_type? := term in term\n  \n                          |   \' pattern inTerm? := term return_type? in term\n                          \n                          \n                          \n  inTerm                ::=   in term\n  \n  terms                 ::=   term+\n\n  match_items           ::=   match_item commaThenMatchItem*\n\n  commaThenMatchItem    ::=   , match_item\n\n  orEquations           ::=   |? equation orEquation*\n\n  orEquation            ::=   | equation\n                          \n                          \n                          \n  arg                   ::=   term\n\n                          |   ( ident := term )\n                          \n                          \n                          \n  binders               ::=   binder+\n                          \n                          \n                          \n  binder                ::=   name\n\n                          |   ( name+ : term )\n\n                          |   ( name colonThenTerm? := term )\n                          \n                          \n                          \n  name                  ::=   ident\n\n                          |   _\n                          \n                          \n                          \n  qualid                ::=   ident<NO_WHITESPACE>access_ident*\n                          \n                          \n                          \n  sort                  ::=   Prop | Set | Type\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  fix_bodies            ::=   fix_body\n  \n                          |   fix_body withFix_body+ for ident\n                          \n  withFix_body          ::=   with fix_body                     \n\n  cofix_bodies          ::=   cofix_body\n  \n                          |   cofix_body withCofix_body+ for ident\n                          \n  withCofix_body        ::=   with cofix_body\n                       \n                       \n                       \n  fix_body              ::=   ident binders annotation? colonThenTerm? := term\n\n  cofix_body            ::=   ident binders? colonThenTerm? := term\n                       \n                       \n                       \n  colonThenTerm         ::=   : term\n                       \n                       \n                       \n  annotation            ::=   { struct ident }\n                       \n                       \n                       \n  match_item            ::=   term asName? inQualidPatterns?\n\n  inQualidPatterns      ::=   in qualid patterns?\n\n  patterns              ::=   pattern+\n  \n  dep_ret_type          ::=   asName? return_type\n\n  asName                ::=   as name\n                       \n                       \n                       \n  return_type           ::=   return term\n                       \n                       \n                       \n  equation              ::=   mult_pattern |ThenMult_pattern* => term\n\n  |ThenMult_pattern     ::=   | mult_pattern\n                       \n                       \n                       \n  mult_pattern          ::=   pattern commaThenPattern*\n                       \n                       \n                       \n  pattern               ::=   @? qualid patterns pattern\'\n  \n                          |   qualid pattern\'\n  \n                          |   _ pattern\'\n  \n                          |   num pattern\'\n  \n                          |   ( or_patterns ) pattern\'\n\n  pattern\'              ::=   as ident pattern\' \n  \n                          |   % ident pattern\' \n  \n                          |   \u03B5\n\n  commaThenPattern      ::=   , pattern\n\n  or_patterns           ::=   or_pattern commaThenOrPattern*\n\n  commaThenOrPattern    ::=   , or_pattern\n                       \n                       \n                       \n  or_pattern            ::=   pattern |ThenPattern*\n\n  |ThenPattern          ::=   | pattern\n\n';

module.exports = grammar;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL2VzNi9ncmFtbWFyL2dhbGxpbmEuanMiXSwibmFtZXMiOlsiZ3JhbW1hciIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLElBQUlBLDYwS0FBSjs7QUE4TUFDLE9BQU9DLE9BQVAsR0FBaUJGLE9BQWpCIiwiZmlsZSI6ImdhbGxpbmEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBncmFtbWFyID0gYFxuXG4gIHRlcm0gICAgICAgICAgICAgICAgICA6Oj0gICBmb3JhbGwgYmluZGVycyAsIHRlcm0gdGVybSdcbiAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHwgICBmdW4gYmluZGVycyA9PiB0ZXJtIHRlcm0nXG4gIFxuICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgZml4IGZpeF9ib2RpZXMgdGVybSdcbiAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHwgICBjb2ZpeCBjb2ZpeF9ib2RpZXMgdGVybSdcbiAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHwgICBsZXQgbGV0JyB0ZXJtJ1xuICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgIGlmIHRlcm0gZGVwX3JldF90eXBlPyB0aGVuIHRlcm0gZWxzZSB0ZXJtIHRlcm0nXG4gIFxuICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgQCBxdWFsaWQgdGVybXM/IHRlcm0nXG4gIFxuICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgbWF0Y2ggbWF0Y2hfaXRlbXMgcmV0dXJuX3R5cGU/IHdpdGggb3JFcXVhdGlvbnM/IGVuZCB0ZXJtJ1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHwgICBxdWFsaWQgdGVybSdcblxuICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgc29ydCB0ZXJtJ1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHwgICBudW0gdGVybSdcblxuICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgXyB0ZXJtJ1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAoIHRlcm0gKSB0ZXJtJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFxuICB0ZXJtJyAgICAgICAgICAgICAgICAgOjo9ICAgOiB0ZXJtIHRlcm0nXG4gIFxuICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgPDogdGVybSB0ZXJtJ1xuICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgIDo+IHRlcm0nXG4gIFxuICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgLT4gdGVybSB0ZXJtJ1xuICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgIGFyZysgdGVybSdcbiAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAlIGlkZW50IHRlcm0nXG4gIFxuICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgzrVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgbGV0JyAgICAgICAgICAgICAgICAgIDo6PSAgIGlkZW50IGJpbmRlcnM/IGNvbG9uVGhlblRlcm0/IDo9IHRlcm0gaW4gdGVybVxuICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgIGZpeCBmaXhfYm9keSBpbiB0ZXJtXG4gIFxuICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgY29maXggY29maXhfYm9keSBpbiB0ZXJtXG4gIFxuICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgKCBuYW1lcyApIGRlcF9yZXRfdHlwZT8gOj0gdGVybSBpbiB0ZXJtXG4gIFxuICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgJyBwYXR0ZXJuIGluVGVybT8gOj0gdGVybSByZXR1cm5fdHlwZT8gaW4gdGVybVxuICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFxuICBpblRlcm0gICAgICAgICAgICAgICAgOjo9ICAgaW4gdGVybVxuICBcbiAgdGVybXMgICAgICAgICAgICAgICAgIDo6PSAgIHRlcm0rXG5cbiAgbWF0Y2hfaXRlbXMgICAgICAgICAgIDo6PSAgIG1hdGNoX2l0ZW0gY29tbWFUaGVuTWF0Y2hJdGVtKlxuXG4gIGNvbW1hVGhlbk1hdGNoSXRlbSAgICA6Oj0gICAsIG1hdGNoX2l0ZW1cblxuICBvckVxdWF0aW9ucyAgICAgICAgICAgOjo9ICAgfD8gZXF1YXRpb24gb3JFcXVhdGlvbipcblxuICBvckVxdWF0aW9uICAgICAgICAgICAgOjo9ICAgfCBlcXVhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFxuICBhcmcgICAgICAgICAgICAgICAgICAgOjo9ICAgdGVybVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAoIGlkZW50IDo9IHRlcm0gKVxuICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFxuICBiaW5kZXJzICAgICAgICAgICAgICAgOjo9ICAgYmluZGVyK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFxuICBiaW5kZXIgICAgICAgICAgICAgICAgOjo9ICAgbmFtZVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAoIG5hbWUrIDogdGVybSApXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICggbmFtZSBjb2xvblRoZW5UZXJtPyA6PSB0ZXJtIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgbmFtZSAgICAgICAgICAgICAgICAgIDo6PSAgIGlkZW50XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgIF9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgcXVhbGlkICAgICAgICAgICAgICAgIDo6PSAgIGlkZW50PE5PX1dISVRFU1BBQ0U+YWNjZXNzX2lkZW50KlxuICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFxuICBzb3J0ICAgICAgICAgICAgICAgICAgOjo9ICAgUHJvcCB8IFNldCB8IFR5cGVcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbiAgZml4X2JvZGllcyAgICAgICAgICAgIDo6PSAgIGZpeF9ib2R5XG4gIFxuICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgZml4X2JvZHkgd2l0aEZpeF9ib2R5KyBmb3IgaWRlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gIHdpdGhGaXhfYm9keSAgICAgICAgICA6Oj0gICB3aXRoIGZpeF9ib2R5ICAgICAgICAgICAgICAgICAgICAgXG5cbiAgY29maXhfYm9kaWVzICAgICAgICAgIDo6PSAgIGNvZml4X2JvZHlcbiAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHwgICBjb2ZpeF9ib2R5IHdpdGhDb2ZpeF9ib2R5KyBmb3IgaWRlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gIHdpdGhDb2ZpeF9ib2R5ICAgICAgICA6Oj0gICB3aXRoIGNvZml4X2JvZHlcbiAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICBcbiAgZml4X2JvZHkgICAgICAgICAgICAgIDo6PSAgIGlkZW50IGJpbmRlcnMgYW5ub3RhdGlvbj8gY29sb25UaGVuVGVybT8gOj0gdGVybVxuXG4gIGNvZml4X2JvZHkgICAgICAgICAgICA6Oj0gICBpZGVudCBiaW5kZXJzPyBjb2xvblRoZW5UZXJtPyA6PSB0ZXJtXG4gICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgXG4gIGNvbG9uVGhlblRlcm0gICAgICAgICA6Oj0gICA6IHRlcm1cbiAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICBcbiAgYW5ub3RhdGlvbiAgICAgICAgICAgIDo6PSAgIHsgc3RydWN0IGlkZW50IH1cbiAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICBcbiAgbWF0Y2hfaXRlbSAgICAgICAgICAgIDo6PSAgIHRlcm0gYXNOYW1lPyBpblF1YWxpZFBhdHRlcm5zP1xuXG4gIGluUXVhbGlkUGF0dGVybnMgICAgICA6Oj0gICBpbiBxdWFsaWQgcGF0dGVybnM/XG5cbiAgcGF0dGVybnMgICAgICAgICAgICAgIDo6PSAgIHBhdHRlcm4rXG4gIFxuICBkZXBfcmV0X3R5cGUgICAgICAgICAgOjo9ICAgYXNOYW1lPyByZXR1cm5fdHlwZVxuXG4gIGFzTmFtZSAgICAgICAgICAgICAgICA6Oj0gICBhcyBuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgXG4gIHJldHVybl90eXBlICAgICAgICAgICA6Oj0gICByZXR1cm4gdGVybVxuICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgIFxuICBlcXVhdGlvbiAgICAgICAgICAgICAgOjo9ICAgbXVsdF9wYXR0ZXJuIHxUaGVuTXVsdF9wYXR0ZXJuKiA9PiB0ZXJtXG5cbiAgfFRoZW5NdWx0X3BhdHRlcm4gICAgIDo6PSAgIHwgbXVsdF9wYXR0ZXJuXG4gICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgXG4gIG11bHRfcGF0dGVybiAgICAgICAgICA6Oj0gICBwYXR0ZXJuIGNvbW1hVGhlblBhdHRlcm4qXG4gICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgXG4gIHBhdHRlcm4gICAgICAgICAgICAgICA6Oj0gICBAPyBxdWFsaWQgcGF0dGVybnMgcGF0dGVybidcbiAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHwgICBxdWFsaWQgcGF0dGVybidcbiAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHwgICBfIHBhdHRlcm4nXG4gIFxuICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgbnVtIHBhdHRlcm4nXG4gIFxuICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgKCBvcl9wYXR0ZXJucyApIHBhdHRlcm4nXG5cbiAgcGF0dGVybicgICAgICAgICAgICAgIDo6PSAgIGFzIGlkZW50IHBhdHRlcm4nIFxuICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICUgaWRlbnQgcGF0dGVybicgXG4gIFxuICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgzrVcblxuICBjb21tYVRoZW5QYXR0ZXJuICAgICAgOjo9ICAgLCBwYXR0ZXJuXG5cbiAgb3JfcGF0dGVybnMgICAgICAgICAgIDo6PSAgIG9yX3BhdHRlcm4gY29tbWFUaGVuT3JQYXR0ZXJuKlxuXG4gIGNvbW1hVGhlbk9yUGF0dGVybiAgICA6Oj0gICAsIG9yX3BhdHRlcm5cbiAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICBcbiAgb3JfcGF0dGVybiAgICAgICAgICAgIDo6PSAgIHBhdHRlcm4gfFRoZW5QYXR0ZXJuKlxuXG4gIHxUaGVuUGF0dGVybiAgICAgICAgICA6Oj0gICB8IHBhdHRlcm5cblxuYDtcblxubW9kdWxlLmV4cG9ydHMgPSBncmFtbWFyO1xuIl19